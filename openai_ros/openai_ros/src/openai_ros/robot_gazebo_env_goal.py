import rospy
import gym
from gym.utils import seeding
from .gazebo_connection import GazeboConnection
from .controllers_connection import ControllersConnection
#https://bitbucket.org/theconstructcore/theconstruct_msgs/src/master/msg/RLExperimentInfo.msg
from theconstruct_msgs.msg import RLExperimentInfo
from controller_manager_msgs.srv import *

class RobotGazeboEnv(gym.GoalEnv):

    def __init__(self, robot_name_space, controllers_list, reset_controls):

        MyControllers = ['arm_controller', 'joint_state_controller']

        # To reset Simulations
        print ("Entered Gazebo Env")
        self.gazebo = GazeboConnection(start_init_physics_parameters=False, reset_world_or_sim="WORLD")
        self.controllers_object = ControllersConnection(namespace=robot_name_space, controllers_list=controllers_list)
        self.reset_controls = reset_controls
        print (self.reset_controls)
        self.seed()

        unspload(MyControllers)
        sp(MyControllers)

        # Set up ROS related variables
        self.episode_num = 0
        self.reward_pub = rospy.Publisher('/openai/reward', RLExperimentInfo, queue_size=1)
        print("Exit Gazebo Env")

    # Env methods
    def seed(self, seed=None):
        self.np_random, seed = seeding.np_random(seed)
        return [seed]

    def step(self, action):
        """
        Function executed each time step.
        Here we get the action execute it in a time step and retrieve the
        observations generated by that action.
        :param action:
        :return: obs, reward, done, info
        """

        """
        Here we should convert the action num to movement action, execute the action in the
        simulation and get the observations result of performing that action.
        """
        print ("Entered step")
        print ("Unpause sim")
        self.gazebo.unpauseSim()
        print ("Set action")
        print ("Action:")
        print (action)
        self._set_action(action)
        print ("Get Obs")
        obs = self._get_obs()
        print ("Is done")
        done = self._is_done(obs)
        info = {}
        reward = self._compute_reward(obs, done)
        self._publish_reward_topic(reward, self.episode_num)

        return obs, reward, done, info

    def reset(self):
        rospy.logdebug("Reseting RobotGazeboEnvironment")
        print ("Entered reset")
        self._reset_sim()
        self._init_env_variables()
        self._update_episode()
        obs = self._get_obs()
        return obs

    def close(self):
        """
        Function executed when closing the environment.
        Use it for closing GUIS and other systems that need closing.
        :return:
        """
        rospy.logdebug("Closing RobotGazeboEnvironment")
        rospy.signal_shutdown("Closing RobotGazeboEnvironment")

    def _update_episode(self):
        """
        Increases the episode number by one
        :return:
        """
        self.episode_num += 1

    def _publish_reward_topic(self, reward, episode_number=1):
        """
        This function publishes the given reward in the reward topic for
        easy access from ROS infrastructure.
        :param reward:
        :param episode_number:
        :return:
        """
        reward_msg = RLExperimentInfo()
        reward_msg.episode_number = episode_number
        reward_msg.episode_reward = reward
        self.reward_pub.publish(reward_msg)

    # Extension methods
    # ----------------------------

    def _reset_sim(self):
        """Resets a simulation
        """
        if self.reset_controls:
            self.gazebo.unpauseSim()
            self.controllers_object.reset_controllers()
            self._check_all_systems_ready()
            self._set_init_pose()
            self.gazebo.pauseSim()
            self.gazebo.resetSim()
            self.gazebo.unpauseSim()
            self.controllers_object.reset_controllers()
            self._check_all_systems_ready()
            self.gazebo.pauseSim()
            
        else:
            self.gazebo.unpauseSim()
            
            self._check_all_systems_ready()
            self._set_init_pose()
            self.gazebo.resetWorld()
            
            self._check_all_systems_ready()
        

        return True

    def _set_init_pose(self):
        """Sets the Robot in its init pose
        """
        raise NotImplementedError()

    def _check_all_systems_ready(self):
        """
        Checks that all the sensors, publishers and other simulation systems are
        operational.
        """
        raise NotImplementedError()

    def _get_obs(self):
        """Returns the observation.
        """
        raise NotImplementedError()

    def _init_env_variables(self):
        """Inits variables needed to be initialised each time we reset at the start
        of an episode.
        """
        raise NotImplementedError()

    def _set_action(self, action):
        """Applies the given action to the simulation.
        """
        raise NotImplementedError()

    def _is_done(self, observations):
        """Indicates whether or not the episode is done ( the robot has fallen for example).
        """
        raise NotImplementedError()

    def _compute_reward(self, observations, done):
        """Calculates the reward to give based on the observations given.
        """
        raise NotImplementedError()

    def _env_setup(self, initial_qpos):
        """Initial configuration of the environment. Can be used to configure initial state
        and extract information from the simulation.
        """
        raise NotImplementedError()


def list_controller_types():
    rospy.wait_for_service('controller_manager/list_controller_types')
    s = rospy.ServiceProxy('controller_manager/list_controller_types', ListControllerTypes)
    resp = s.call(ListControllerTypesRequest())
    for t in resp.types:
        print (t)

def start_stop_controllers(names, st):
    rospy.wait_for_service('controller_manager/switch_controller')
    s = rospy.ServiceProxy('controller_manager/switch_controller', SwitchController)
    start = []
    stop = []
    strictness = SwitchControllerRequest.STRICT
    if st:
        start = names
    else:
        stop = names
    resp = s.call(SwitchControllerRequest(start, stop, strictness))
    if resp.ok == 1:
        if st:
            print("Started {} successfully".format(names))
        else:
            print("Stopped {} successfully".format(names))
        return True
    else:
        if st:
            print("Error when starting ", names)
        else:
            print("Error when stopping ", names)
        return False


def start_controller(name):
    return start_stop_controllers([name], True)

def unload_controller(name):
    rospy.wait_for_service('controller_manager/unload_controller')
    s = rospy.ServiceProxy('controller_manager/unload_controller', UnloadController)
    resp = s.call(UnloadControllerRequest(name))
    if resp.ok == 1:
        print ("Unloaded %s successfully" % name)
        return True
    else:
        print ("Error when unloading", name)
        return False


def load_controller(name):
    rospy.wait_for_service('controller_manager/load_controller')
    s = rospy.ServiceProxy('controller_manager/load_controller', LoadController)
    resp = s.call(LoadControllerRequest(name))
    if resp.ok:
        print("Loaded", name)
        return True
    else:
        print("Error when loading", name)
        return False

def sp(MyControllers):

    load_controller(MyControllers[0])
    start_controller(MyControllers[0])
    load_controller(MyControllers[1])
    start_controller(MyControllers[1])

def unspload(MyControllers):


    switch_controller = rospy.ServiceProxy('/controller_manager/switch_controller', SwitchController)
    list_controllers = rospy.ServiceProxy('/controller_manager/list_controllers', ListControllers)

    switch_controller.wait_for_service()
    list_controllers.wait_for_service()
    inhibited = set()

    #to_inhibit = set(rospy.myargv())
    to_inhibit = set(MyControllers)

    def stop_controllers(*argc):
        to_stop = to_inhibit & set(cs.name for cs in list_controllers().controller if cs.state == 'running')

        if to_stop:
            rospy.logout("Inhibiting controllers: %s" % ', '.join(to_stop))
            print("bn3ml service")
            #switch_controller(strictness = SwitchControllerRequest.BEST_EFFORT, stop_controllers = list(to_stop))
            #switch_controller(strictness = SwitchControllerRequest.STRICT, stop_controllers = list(to_stop))
            resp = switch_controller.call(SwitchControllerRequest([], list(to_stop), SwitchControllerRequest.BEST_EFFORT)) 
#    resp = s.call(SwitchControllerRequest(start, stop, strictness))
            print("5lsna service")
            inhibited.update(to_stop)

    stop_controllers()
#    timer = rospy.Timer(rospy.Duration(3), stop_controllers)

    #while(not (resp.ok==1)):
     #    print("m7na fadyeen b2a")
    ##hna unload
    print("heeh")
    unload_controller(MyControllers[0])
    unload_controller(MyControllers[1])

    def restart_controllers():
        #timer.shutdown()
        # Re-starts inhibited controllers
        switch_controller(strictness = SwitchControllerRequest.BEST_EFFORT,
                          start_controllers = list(inhibited))

    restart_controllers()
    #rospy.on_shutdown(restart_controllers)
    #rospy.spin()
    #sys.exit(1)

